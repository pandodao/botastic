// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"strings"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gen/helper"

	"github.com/pandodao/botastic/core"

	"github.com/shopspring/decimal"
)

func newOrder(db *gorm.DB, opts ...gen.DOOption) order {
	_order := order{}

	_order.orderDo.UseDB(db, opts...)
	_order.orderDo.UseModel(&core.Order{})

	tableName := _order.orderDo.TableName()
	_order.ALL = field.NewAsterisk(tableName)
	_order.ID = field.NewString(tableName, "id")
	_order.UserID = field.NewUint64(tableName, "user_id")
	_order.Channel = field.NewString(tableName, "channel")
	_order.Status = field.NewString(tableName, "status")
	_order.PayeeId = field.NewString(tableName, "payee_id")
	_order.QuoteAmount = field.NewField(tableName, "quote_amount")
	_order.QuoteAssetId = field.NewString(tableName, "quote_asset_id")
	_order.TraceID = field.NewString(tableName, "trace_id")
	_order.UpstreamStatus = field.NewString(tableName, "upstream_status")
	_order.Raw = field.NewString(tableName, "raw")
	_order.CreatedAt = field.NewTime(tableName, "created_at")
	_order.UpdatedAt = field.NewTime(tableName, "updated_at")

	_order.fillFieldMap()

	return _order
}

type order struct {
	orderDo

	ALL            field.Asterisk
	ID             field.String
	UserID         field.Uint64
	Channel        field.String
	Status         field.String
	PayeeId        field.String
	QuoteAmount    field.Field
	QuoteAssetId   field.String
	TraceID        field.String
	UpstreamStatus field.String
	Raw            field.String
	CreatedAt      field.Time
	UpdatedAt      field.Time

	fieldMap map[string]field.Expr
}

func (o order) Table(newTableName string) *order {
	o.orderDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o order) As(alias string) *order {
	o.orderDo.DO = *(o.orderDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *order) updateTableName(table string) *order {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewString(table, "id")
	o.UserID = field.NewUint64(table, "user_id")
	o.Channel = field.NewString(table, "channel")
	o.Status = field.NewString(table, "status")
	o.PayeeId = field.NewString(table, "payee_id")
	o.QuoteAmount = field.NewField(table, "quote_amount")
	o.QuoteAssetId = field.NewString(table, "quote_asset_id")
	o.TraceID = field.NewString(table, "trace_id")
	o.UpstreamStatus = field.NewString(table, "upstream_status")
	o.Raw = field.NewString(table, "raw")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")

	o.fillFieldMap()

	return o
}

func (o *order) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *order) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 12)
	o.fieldMap["id"] = o.ID
	o.fieldMap["user_id"] = o.UserID
	o.fieldMap["channel"] = o.Channel
	o.fieldMap["status"] = o.Status
	o.fieldMap["payee_id"] = o.PayeeId
	o.fieldMap["quote_amount"] = o.QuoteAmount
	o.fieldMap["quote_asset_id"] = o.QuoteAssetId
	o.fieldMap["trace_id"] = o.TraceID
	o.fieldMap["upstream_status"] = o.UpstreamStatus
	o.fieldMap["raw"] = o.Raw
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
}

func (o order) clone(db *gorm.DB) order {
	o.orderDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o order) replaceDB(db *gorm.DB) order {
	o.orderDo.ReplaceDB(db)
	return o
}

type orderDo struct{ gen.DO }

type IOrderDo interface {
	WithContext(ctx context.Context) IOrderDo

	CreateOrder(ctx context.Context, id string, userId uint64, channel core.OrderChannel, status core.OrderStatus, payeeId string, quoteAmount decimal.Decimal, quoteAssetId string, traceId string) (err error)
	UpdateOrder(ctx context.Context, id string, upstreamStatus string, status core.OrderStatus, raw string) (err error)
	GetOrder(ctx context.Context, id string) (result *core.Order, err error)
	GetOrdersByStatus(ctx context.Context, status core.OrderStatus) (result []*core.Order, err error)
	UpdateOrderStatus(ctx context.Context, id string, status core.OrderStatus) (err error)
}

// INSERT INTO @@table
//
//	("id", "user_id", "channel", "status", "payee_id", "quote_amount", "quote_asset_id", "trace_id", "created_at", "updated_at")
//
// VALUES
//
//	(@id, @userId, @channel, @status, @payeeId, @quoteAmount, @quoteAssetId, @traceId, NOW(), NOW())
func (o orderDo) CreateOrder(ctx context.Context, id string, userId uint64, channel core.OrderChannel, status core.OrderStatus, payeeId string, quoteAmount decimal.Decimal, quoteAssetId string, traceId string) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	params = append(params, userId)
	params = append(params, channel)
	params = append(params, status)
	params = append(params, payeeId)
	params = append(params, quoteAmount)
	params = append(params, quoteAssetId)
	params = append(params, traceId)
	generateSQL.WriteString("INSERT INTO orders (\"id\", \"user_id\", \"channel\", \"status\", \"payee_id\", \"quote_amount\", \"quote_asset_id\", \"trace_id\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW()) ")

	var executeSQL *gorm.DB
	executeSQL = o.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// UPDATE @@table
//
//	{{set}}
//		"upstream_status"=@upstreamStatus,
//		"status"=@status,
//		"raw"=@raw,
//		"updated_at"=NOW()
//	{{end}}
//
// WHERE
//
//	"id"=@id
func (o orderDo) UpdateOrder(ctx context.Context, id string, upstreamStatus string, status core.OrderStatus, raw string) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("UPDATE orders ")
	var setSQL0 strings.Builder
	params = append(params, upstreamStatus)
	params = append(params, status)
	params = append(params, raw)
	setSQL0.WriteString("\"upstream_status\"=?, \"status\"=?, \"raw\"=?, \"updated_at\"=NOW() ")
	helper.JoinSetBuilder(&generateSQL, setSQL0)
	params = append(params, id)
	generateSQL.WriteString("WHERE \"id\"=? ")

	var executeSQL *gorm.DB
	executeSQL = o.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT *
// FROM @@table WHERE
//
//	"id"=@id
//
// LIMIT 1
func (o orderDo) GetOrder(ctx context.Context, id string) (result *core.Order, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM orders WHERE \"id\"=? LIMIT 1 ")

	var executeSQL *gorm.DB
	executeSQL = o.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT *
// FROM @@table WHERE
//
//	"status"=@status
func (o orderDo) GetOrdersByStatus(ctx context.Context, status core.OrderStatus) (result []*core.Order, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, status)
	generateSQL.WriteString("SELECT * FROM orders WHERE \"status\"=? ")

	var executeSQL *gorm.DB
	executeSQL = o.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// UPDATE @@table
//
//	{{set}}
//		"status"=@status,
//		"updated_at"=NOW()
//	{{end}}
//
// WHERE
//
//	"id"=@id
func (o orderDo) UpdateOrderStatus(ctx context.Context, id string, status core.OrderStatus) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("UPDATE orders ")
	var setSQL0 strings.Builder
	params = append(params, status)
	setSQL0.WriteString("\"status\"=?, \"updated_at\"=NOW() ")
	helper.JoinSetBuilder(&generateSQL, setSQL0)
	params = append(params, id)
	generateSQL.WriteString("WHERE \"id\"=? ")

	var executeSQL *gorm.DB
	executeSQL = o.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (o orderDo) WithContext(ctx context.Context) IOrderDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o *orderDo) withDO(do gen.Dao) *orderDo {
	o.DO = *do.(*gen.DO)
	return o
}
